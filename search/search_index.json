{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Sinapses \u00b6 Apresenta\u00e7\u00e3o \u00b6 Seja muito bem-vindi ao Sinapse. Um espa\u00e7o mais livre, mais bagun\u00e7ado e bem mais livre de assunto. A ideia aqui \u00e9 fazer uma apanhado das coisas que eu vi e me interessei, o ainda dar uma nova vis\u00e3o sobre assunto que acho interessante. Como Funciona \u00b6 No lado esquerdo vemos uma toc (do ingl\u00eas table of contents ), nela podemos explorar alguns t\u00f3picos a qual eu j\u00e1 escrevi algo ou fiz um mini tutorial. Bem, \u00e9 variado... Ao lado direito vemos uma outra toc, mas dessa vez dessa p\u00e1gina. Fique \u00e0 vontade para explorar. Quem Sou Eu \u00b6 Cristiano M B Azarias \u00e9 bacharelando em engenharia de instrumenta\u00e7\u00e3o, automa\u00e7\u00e3o e rob\u00f3tica e tamb\u00e9m bacharelando em neuroci\u00eancia na Universidade Federal do ABC . Pesquisador no Timing and Cognition Lab na \u00e1rea de cogni\u00e7\u00e3o e tempo. Coment\u00e1rios e Sugest\u00f5es \u00b6 Coment\u00e1rios e sugest\u00f5es s\u00e3o sempre muito bem-vindas. Por favor, entre em contato por e-mail , ou assine ao feed para receber um e-mail quando tivermos atualiza\u00e7\u00f5es.","title":"In\u00edcio"},{"location":"#sinapses","text":"","title":"Sinapses"},{"location":"#apresentacao","text":"Seja muito bem-vindi ao Sinapse. Um espa\u00e7o mais livre, mais bagun\u00e7ado e bem mais livre de assunto. A ideia aqui \u00e9 fazer uma apanhado das coisas que eu vi e me interessei, o ainda dar uma nova vis\u00e3o sobre assunto que acho interessante.","title":"Apresenta\u00e7\u00e3o"},{"location":"#como-funciona","text":"No lado esquerdo vemos uma toc (do ingl\u00eas table of contents ), nela podemos explorar alguns t\u00f3picos a qual eu j\u00e1 escrevi algo ou fiz um mini tutorial. Bem, \u00e9 variado... Ao lado direito vemos uma outra toc, mas dessa vez dessa p\u00e1gina. Fique \u00e0 vontade para explorar.","title":"Como Funciona"},{"location":"#quem-sou-eu","text":"Cristiano M B Azarias \u00e9 bacharelando em engenharia de instrumenta\u00e7\u00e3o, automa\u00e7\u00e3o e rob\u00f3tica e tamb\u00e9m bacharelando em neuroci\u00eancia na Universidade Federal do ABC . Pesquisador no Timing and Cognition Lab na \u00e1rea de cogni\u00e7\u00e3o e tempo.","title":"Quem Sou Eu"},{"location":"#comentarios-e-sugestoes","text":"Coment\u00e1rios e sugest\u00f5es s\u00e3o sempre muito bem-vindas. Por favor, entre em contato por e-mail , ou assine ao feed para receber um e-mail quando tivermos atualiza\u00e7\u00f5es.","title":"Coment\u00e1rios e Sugest\u00f5es"},{"location":"MachineLearning/NLP/bert/","text":"BERT - Bidirectional Encoder Representations from Transformers \u00b6 Um dos grandes problemas na \u00e1rea de processamento de linguagem natural ( NLP ) \u00e9 a escassez de dados de treino. Isso pode soar paradoxal uma vez que estamos submergidos em textos e mais textos na internet, contudo n\u00e3o \u00e9. A campo do NLP \u00e9 diverso e com diversas aplica\u00e7\u00f5es. At\u00e9 podemos achar alguns datasets com prop\u00f3sitos bem espec\u00edficos, mas eles s\u00e3o pequenos, indo de alguns milhares at\u00e9 algumas centenas de milhares de dados com dados tags e labels. E como os os modelos de deep-learning modernos tanto para linguagem, quanto para outros prop\u00f3sitos se beneficiam das grandes quantidades de dados, temos alguns problemas. Tendo isso em vista, os pesquisadores desenvolveram algumas t\u00e9cnicas para treinar modelos de linguagem bem generalistas. Imagine que estamos ensinando um cachorro a falar se frases s\u00e3o positivas ou negativas. Podemos treinar o nosso canino nessa essa tarefa, mas ser\u00e1 bem dif\u00edcil e precisaremos de muitos exemplos de treino. Agora, vamos mudar a nossa estrat\u00e9gia. Ao inv\u00e9s de ensinar o nosso amigo a diferenciar frases positivas e negativas primeiro vamos ensin\u00e1-lo o que \u00e9 a l\u00edngua, o que s\u00e3o palavras, frases e como elas aparecem numa senten\u00e7a. E n\u00e3o \u00e9 que conseguimos?! Temos um cachorro versado em portugu\u00eas agora. Agora que o nosso c\u00e3o sabe o que s\u00e3o frases, como elas s\u00e3o compostas e as depend\u00eancias dentro de uma senten\u00e7a podemos ensin\u00e1-lo frases positivas e negativas. Como ele tem ess conhecimento bem amplo na l\u00edngua n\u00e3o demora muito at\u00e9 ele aprender. Na literatura isso \u00e9 chamado de pr\u00e9-treino e ajuste fino respectivamente. Dessa forma, pesquisadores usam corpus lingu\u00edsticos extensos como a Wikepedia, ou o Google Books para fazer o pre-training dos modelos na l\u00edngua e depois usam datasets menores ( IMDb , YELP , Tiny Shakespeare , Amazon Reviews ) para fazer o fine-tunning. To help close this gap in data, researchers have developed a variety of techniques for training general purpose language representation models using the enormous amount of unannotated text on the web (known as pre-training). The pre-trained model can then be fine-tuned on small-data NLP tasks like question answering and sentiment analysis, resulting in substantial accuracy improvements compared to training on these datasets from scratch.","title":"BERT - Bidirectional Encoder Representations from Transformers"},{"location":"MachineLearning/NLP/bert/#bert-bidirectional-encoder-representations-from-transformers","text":"Um dos grandes problemas na \u00e1rea de processamento de linguagem natural ( NLP ) \u00e9 a escassez de dados de treino. Isso pode soar paradoxal uma vez que estamos submergidos em textos e mais textos na internet, contudo n\u00e3o \u00e9. A campo do NLP \u00e9 diverso e com diversas aplica\u00e7\u00f5es. At\u00e9 podemos achar alguns datasets com prop\u00f3sitos bem espec\u00edficos, mas eles s\u00e3o pequenos, indo de alguns milhares at\u00e9 algumas centenas de milhares de dados com dados tags e labels. E como os os modelos de deep-learning modernos tanto para linguagem, quanto para outros prop\u00f3sitos se beneficiam das grandes quantidades de dados, temos alguns problemas. Tendo isso em vista, os pesquisadores desenvolveram algumas t\u00e9cnicas para treinar modelos de linguagem bem generalistas. Imagine que estamos ensinando um cachorro a falar se frases s\u00e3o positivas ou negativas. Podemos treinar o nosso canino nessa essa tarefa, mas ser\u00e1 bem dif\u00edcil e precisaremos de muitos exemplos de treino. Agora, vamos mudar a nossa estrat\u00e9gia. Ao inv\u00e9s de ensinar o nosso amigo a diferenciar frases positivas e negativas primeiro vamos ensin\u00e1-lo o que \u00e9 a l\u00edngua, o que s\u00e3o palavras, frases e como elas aparecem numa senten\u00e7a. E n\u00e3o \u00e9 que conseguimos?! Temos um cachorro versado em portugu\u00eas agora. Agora que o nosso c\u00e3o sabe o que s\u00e3o frases, como elas s\u00e3o compostas e as depend\u00eancias dentro de uma senten\u00e7a podemos ensin\u00e1-lo frases positivas e negativas. Como ele tem ess conhecimento bem amplo na l\u00edngua n\u00e3o demora muito at\u00e9 ele aprender. Na literatura isso \u00e9 chamado de pr\u00e9-treino e ajuste fino respectivamente. Dessa forma, pesquisadores usam corpus lingu\u00edsticos extensos como a Wikepedia, ou o Google Books para fazer o pre-training dos modelos na l\u00edngua e depois usam datasets menores ( IMDb , YELP , Tiny Shakespeare , Amazon Reviews ) para fazer o fine-tunning. To help close this gap in data, researchers have developed a variety of techniques for training general purpose language representation models using the enormous amount of unannotated text on the web (known as pre-training). The pre-trained model can then be fine-tuned on small-data NLP tasks like question answering and sentiment analysis, resulting in substantial accuracy improvements compared to training on these datasets from scratch.","title":"BERT - Bidirectional Encoder Representations from Transformers"},{"location":"simulacoes/finances/","text":"Finan\u00e7as Simuladas - EDOs \u00b6 **Disclaimer Antes de mais nada, vale dizer que minha forma\u00e7\u00e3o n\u00e3o \u00e9 voltada para econ\u00f4mia. Mesmo que no curso de engenharia tenhamos disciplinas como engenharia econ\u00f4mica, ela n\u00e3o fornece uma vis\u00e3o macrosc\u00f3pica e nem o a base suficiente para criar modelos econ\u00f4micos que se apliquem ao mercado financeiro. Tendo posto isso, esse post foca mais na utiliza\u00e7\u00e3o de equa\u00e7\u00f5es diferenciais e suas interpreta\u00e7\u00f5es assim como a programa\u00e7\u00e3o matem\u00e1tica por tr\u00e1s. Durante o post e ao fim dele ter\u00e3o algumas refer\u00eancias para o aprofundamento em econ\u00f4mia de fato bem como os outros conceitos matem\u00e1ticos. Vale ressaltar que esses modelos n\u00e3o devem ser levados ao p\u00e9 da letra, mas nos trazem algumas intui\u00e7\u00f5es sobre o assunto. Introdu\u00e7\u00e3o \u00b6 Lembra do caso Bettina, \"Oi, eu sou a Bettina e tenho 1 milh\u00e3o e 42 mil reais em patrim\u00f4nio acumulado...\" ? Bem, esse tipo propaganda super apelativa fingem que a independ\u00eancia financeira \u00e9 algo bem direto e f\u00e1cil. Por\u00e9m, n\u00e3o s\u00e3o. Esse caminho no geral envolve uma s\u00e9rie de fatores a serem levados em considera\u00e7\u00e3o e que dificultam muito o racioc\u00ednio l\u00f3gico. Nesse post, a ideia \u00e9 tentar modelar esse problema econ\u00f4mico com um pouco de matem\u00e1tica e programa\u00e7\u00e3o. Dessa forma, construiremos uma carteira financeira utilizando algumas equa\u00e7\u00f5es diferenciais ordin\u00e1rias ( EDOs ) e alguns scripts para integrar e visualizar as din\u00e2micas. O Problema \u00b6 Na grande maioria dos problemas naturais podemos avali\u00e1-los de duas maneiras diferentes. A primeira maneira \u00e9 verificar, neste exemplo de uma carteira financeira, quanto dinheiro temos num dado tempo . A segunda maneira - e a que usaremos - \u00e9 verificar quanto o dinheiro muda com o tempo . Dessa forma, sabendo a primeira derivada, \\frac{dx}{dt} \\frac{dx}{dt} , e a condi\u00e7\u00e3o inicial, x_0 = x(0) x_0 = x(0) , conseguimos calcular os bens futuros. Assim, para encontramos x(t) x(t) que satisfa\u00e7a a nossa EDO, basta integramos x(t) = \\int_0^t \\dfrac{dx}{dt} dt x(t) = \\int_0^t \\dfrac{dx}{dt} dt 1\u00aa Modelagem \u00b6 Vamos come\u00e7ar com um caso simples. Nossas finan\u00e7as s\u00e3o baseadas nos seguintes fatores: Nossa renda mensal, r(t) r(t) . Todas as nossas despesas (contas, alimenta\u00e7\u00e3o, moradia, etc), d(t) d(t) . As taxas que voc\u00ea paga sobre o seu sal\u00e1rio, T(a) T(a) . Dessa forma podemos dizer que o seu ganho, i.e., a taxa com que voc\u00ea ganha ou perde dinheiro pode ser escrita como \\delta = r(t) - d(t) - T(a) \\delta = r(t) - d(t) - T(a) Neste caso, \\delta \\delta \u00e9 o seu ganho. Assim, a EDO pode ser escrita como \\dfrac{dx}{dt} = \\delta \\dfrac{dx}{dt} = \\delta Dados r(t) r(t) , d(t) d(t) e T(a) T(a) constantes, podemos resolver integrando facilmente \\int_{x_0}^{x(t)} dx = \\int_0^t \\delta~dt \\Rightarrow x(t) = \\delta t + x_0 \\int_{x_0}^{x(t)} dx = \\int_0^t \\delta~dt \\Rightarrow x(t) = \\delta t + x_0 Como mantemos tudo constante, nossa equa\u00e7\u00e3o final ser\u00e1 uma reta. Transformando a matem\u00e1tica em c\u00f3digo teremos o seguinte: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Carteira : def __init__ ( self , salario = 1600 , despesas = 500 , taxas =. 1 ): self . salario = salario self . despesas = despesas self . taxas = taxas def ganho ( self , t ): return 12 * self . salario def gastos ( self , t ): return 12 * self . despesas def pagamentos ( self , t ): return self . taxas * self . ganho ( t ) def modelo ( self , t ): return self . ganho ( t ) - self . gastos ( t ) - self . pagamentos ( t ) def integrar ( self , t_init , t_end , y0 , h = 0.001 ): N = int (( t_end - t_init ) / h ) x = np . linspace ( t_init , t_end , N ) y = np . zeros ( N ) y [ 0 ] = y0 for i in range ( N - 1 ): y [ i + 1 ] = y [ i ] + h * self . modelo ( x [ i ]) return x , y Com um sal\u00e1rio de 1600 reais, despesas de 500 reais e os descontos salariais de 10%, teremos a reta abaixo. Vale dizer que a granularidade temporal \u00e9 de um ano. Para integrar a nossa EDO, ao inv\u00e9s de usar um pacote pronto, escrevemos a fun\u00e7\u00e3o integrar () . Essa fun\u00e7\u00e3o \u00e9 a implementa\u00e7\u00e3o do m\u00e9todo de Euler para resolver EDOs - veja mais aqui . Parando para ver o nosso modelo, n\u00e3o faz sentido pensarmos que desde que nascemos ganhemos um sal\u00e1rio. Al\u00e9m disso, todos queremos nos aposentar um dia. No nosso modelo, trabalhamos at\u00e9 morrer aos 100 anos. Bem, fica dif\u00edcil viver at\u00e9 os 100 trabalhando desde o nascimento... Vamos introduzir isso ao modelo! 1\u00aa Modelagem + Descontinuidades \u00b6 Como a integral \u00e9 um operador linear - uma maneira bonitinha de dizer que a integral da soma \u00e9 a soma das integrais. Dessa forma, \u00e9 v\u00e1lido fazermos a seguinte opera\u00e7\u00e3o: x(t) = \\int_{nascimento}^{t_1} \\dfrac{dx}{dt}~dt + \\int_{t_1}^{t_2} \\dfrac{dx}{dt}~dt + \\int_{t_2}^{morte} \\dfrac{dx}{dt}~dt x(t) = \\int_{nascimento}^{t_1} \\dfrac{dx}{dt}~dt + \\int_{t_1}^{t_2} \\dfrac{dx}{dt}~dt + \\int_{t_2}^{morte} \\dfrac{dx}{dt}~dt Dessa forma teremos 3 momentos distintos nas nossas vidas Inf\u00e2ncia: quando somos dependentes dos nossos pais e n\u00e3o temos um sal\u00e1rio e nem despesas. Vida Ativa: quando ganhamos, gastamos e pagamos taxas. Aposentadoria: quando n\u00e3o temos mais um sal\u00e1rio, mas ganhamos uma aposentadoria que \u00e9 menor que o nosso sal\u00e1rio. Al\u00e9m disso ainda temos despesas e taxas. Nosso c\u00f3digo muda um pouco. Vamos acrescentar essas descontinuidades ao ganho e aos gastos. Para integrar esse modelos agora, definimos uma fun\u00e7\u00e3o simula\u00e7\u00e3o. Nela executamos integramos passo a passo cada um dos est\u00e1gios. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 class Carteira : def __init__ ( self , salario = 1600 , despesas = 500 , taxas =. 1 , aposentadoria = 1000 , atividade = 18 , descanso = 70 ): self . salario = salario self . despesas = despesas self . taxas = taxas self . aposentadoria = aposentadoria self . atividade = atividade self . descanso = descanso def ganho ( self , t ): if t < self . atividade : return 0 elif self . atividade <= t < self . descanso : return 12 * self . salario else : return 12 * self . aposentadoria def gastos ( self , t ): if t < self . atividade : return 0 else : return 12 * self . despesas def pagamentos ( self , t ): return self . taxas * self . ganho ( t ) def modelo ( self , t ): return self . ganho ( t ) - self . gastos ( t ) - self . pagamentos ( t ) def integrar ( self , t_init , t_end , y0 , h = 0.001 ): N = int (( t_end - t_init ) / h ) x = np . linspace ( t_init , t_end , N ) y = np . zeros ( N ) y [ 0 ] = y0 for i in range ( N - 1 ): y [ i + 1 ] = y [ i ] + h * self . modelo ( x [ i ]) return x , y def simulacao ( carteira ): x0 , y0 = carteira . integrar ( 0 , carteira . atividade , 0 ) x1 , y1 = carteira . integrar ( carteira . atividade , carteira . descanso , y0 [ - 1 ]) x2 , y2 = carteira . integrar ( carteira . descanso , 100 , y1 [ - 1 ]) return np . concatenate (( x0 , x1 , x2 )), np . concatenate (( y0 , y1 , y2 )) Mesmo com a fun\u00e7\u00e3o \\frac{dx}{dt} \\frac{dx}{dt} tendo uma s\u00e9rie de descontinuidades, a fun\u00e7\u00e3o x(t) x(t) 2\u00aa Modelagem \u00b6 Bem, a menos que sejamos alunos de inicia\u00e7\u00e3o cient\u00edfica, n\u00f3s esperamos que o nosso sal\u00e1rio aumente em fun\u00e7\u00e3o do tempo. Al\u00e9m disso, \u00e9 f\u00e1cil pensarmos que nossos gastos tamb\u00e9m aumentaram em fun\u00e7\u00e3o do tempo. \\begin{cases} r(t) = \\alpha~t + r_0\\\\ d(t) = \\beta~t + d_0\\\\ \\end{cases} \\begin{cases} r(t) = \\alpha~t + r_0\\\\ d(t) = \\beta~t + d_0\\\\ \\end{cases} Neste caso, \\alpha \\alpha \u00e9 a taxa de aumento salarial, ou o reajuste salarial, e \\beta \\beta o aumento das despesas, ou o reajuste de despesas. Agora nossa fun\u00e7\u00e3o \\delta \\delta ser\u00e1 dependente do tempo. Esta depend\u00eancia temporal na derivada primeira trar\u00e1 um perfil quadr\u00e1tico na fun\u00e7\u00e3o x(t) x(t) . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 class Carteira : def __init__ ( self , salario = 1600 , despesas = 500 , taxas =. 1 , aposentadoria = 1000 , atividade = 18 , descanso = 70 , alpha = 120 , beta = 80 ): self . salario = salario self . despesas = despesas self . taxas = taxas self . aposentadoria = aposentadoria self . atividade = atividade self . descanso = descanso self . reajuste_salarial = alpha self . reajuste_despesas = beta def ganho ( self , t ): if t < self . atividade : return 0 elif self . atividade <= t < self . descanso : return 12 * ( self . salario + self . reajuste_salarial \\ * ( t - self . atividade )) else : return 12 * self . aposentadoria def gastos ( self , t ): if t < self . atividade : return 0 else : return 12 * ( self . despesas + self . reajuste_despesas \\ * ( t - self . atividade )) def pagamentos ( self , t ): return self . taxas * self . ganho ( t ) def modelo ( self , t ): return self . ganho ( t ) - self . gastos ( t ) - self . pagamentos ( t ) def integrar ( self , t_init , t_end , y0 , h = 0.001 ): N = int (( t_end - t_init ) / h ) x = np . linspace ( t_init , t_end , N ) y = np . zeros ( N ) y [ 0 ] = y0 for i in range ( N - 1 ): y [ i + 1 ] = y [ i ] + h * self . modelo ( x [ i ]) return x , y def simulacao ( carteira ): x0 , y0 = carteira . integrar ( 0 , carteira . atividade , 0 ) x1 , y1 = carteira . integrar ( carteira . atividade , carteira . descanso , y0 [ - 1 ]) x2 , y2 = carteira . integrar ( carteira . descanso , 100 , y1 [ - 1 ]) return np . concatenate (( x0 , x1 , x2 )), np . concatenate (( y0 , y1 , y2 )) Como podemos ver, a nossa fun\u00e7\u00e3o exibe o perfil quadr\u00e1tico que previmos anteriormente. Al\u00e9m disso, vemos grandes diferen\u00e7as nos resultados das integra\u00e7\u00f5es. E bem, como estamos devendo, talvez seja hora de come\u00e7armos a investir para sairmos desse vermelho. 3\u00aa Modelagem \u00b6 Agora chegou aquele momento de lembrarmos das aulas de engenharia econ\u00f4mica e da m\u00e1gica dos juros compostos. A f\u00f3rmula para isso \u00e9 f\u00e1cil M = C\\cdot(1+i)^n M = C\\cdot(1+i)^n onde, M M \u00e9 o montante, C C o capital inicial, i i a taxa de juros compostos e n n o per\u00edodo de aplica\u00e7\u00e3o. A \"m\u00e1gica\" dos juros compostos na verdade \u00e9 a aplica\u00e7\u00e3o de juros sobre juros, ou seja, \u00e9 como se peg\u00e1ssemos tudo o que j\u00e1 ganhamos e invest\u00edssemos novamente sobre o mesmo regime de juros. Mas vamos lembrar que estamos trabalhando com EDOs, assim vamos tomar a derivada dessa equa\u00e7\u00e3o: \\begin{cases} x(t) = x_0(1+i)^t\\\\ \\dfrac{dx}{dt} = x_0(1+i)^t\\ln{(R+1)} = x(t)\\ln{(R+1)} \\end{cases} \\begin{cases} x(t) = x_0(1+i)^t\\\\ \\dfrac{dx}{dt} = x_0(1+i)^t\\ln{(R+1)} = x(t)\\ln{(R+1)} \\end{cases} Como podemos ver, a derivada da fun\u00e7\u00e3o juros composto \u00e9 proporcional a ela mesma. Agora \u00e9 onde tudo fica ainda mais interessante. Com essa nova equa\u00e7\u00e3o diferencial podemos introduzir um fator investimento na nossa carteira. Todavia, ao inv\u00e9s de fixarmos um capital inicial, vamos disponibilizar um fator \\beta \\beta do nosso dinheiro para ser investido, onde \\beta\\in[0, 1] \\beta\\in[0, 1] . Dessa forma teremos a seguintes equa\u00e7\u00f5es: \\begin{cases} \\dot{x_1} = (1-\\beta)~\\delta\\\\ \\dot{x_2} = \\beta~\\delta + x_2\\ln{(1+R)} \\end{cases} \\begin{cases} \\dot{x_1} = (1-\\beta)~\\delta\\\\ \\dot{x_2} = \\beta~\\delta + x_2\\ln{(1+R)} \\end{cases}","title":"Finan\u00e7as Simuladas"},{"location":"simulacoes/finances/#financas-simuladas-edos","text":"**Disclaimer Antes de mais nada, vale dizer que minha forma\u00e7\u00e3o n\u00e3o \u00e9 voltada para econ\u00f4mia. Mesmo que no curso de engenharia tenhamos disciplinas como engenharia econ\u00f4mica, ela n\u00e3o fornece uma vis\u00e3o macrosc\u00f3pica e nem o a base suficiente para criar modelos econ\u00f4micos que se apliquem ao mercado financeiro. Tendo posto isso, esse post foca mais na utiliza\u00e7\u00e3o de equa\u00e7\u00f5es diferenciais e suas interpreta\u00e7\u00f5es assim como a programa\u00e7\u00e3o matem\u00e1tica por tr\u00e1s. Durante o post e ao fim dele ter\u00e3o algumas refer\u00eancias para o aprofundamento em econ\u00f4mia de fato bem como os outros conceitos matem\u00e1ticos. Vale ressaltar que esses modelos n\u00e3o devem ser levados ao p\u00e9 da letra, mas nos trazem algumas intui\u00e7\u00f5es sobre o assunto.","title":"Finan\u00e7as Simuladas - EDOs"},{"location":"simulacoes/finances/#introducao","text":"Lembra do caso Bettina, \"Oi, eu sou a Bettina e tenho 1 milh\u00e3o e 42 mil reais em patrim\u00f4nio acumulado...\" ? Bem, esse tipo propaganda super apelativa fingem que a independ\u00eancia financeira \u00e9 algo bem direto e f\u00e1cil. Por\u00e9m, n\u00e3o s\u00e3o. Esse caminho no geral envolve uma s\u00e9rie de fatores a serem levados em considera\u00e7\u00e3o e que dificultam muito o racioc\u00ednio l\u00f3gico. Nesse post, a ideia \u00e9 tentar modelar esse problema econ\u00f4mico com um pouco de matem\u00e1tica e programa\u00e7\u00e3o. Dessa forma, construiremos uma carteira financeira utilizando algumas equa\u00e7\u00f5es diferenciais ordin\u00e1rias ( EDOs ) e alguns scripts para integrar e visualizar as din\u00e2micas.","title":"Introdu\u00e7\u00e3o"},{"location":"simulacoes/finances/#o-problema","text":"Na grande maioria dos problemas naturais podemos avali\u00e1-los de duas maneiras diferentes. A primeira maneira \u00e9 verificar, neste exemplo de uma carteira financeira, quanto dinheiro temos num dado tempo . A segunda maneira - e a que usaremos - \u00e9 verificar quanto o dinheiro muda com o tempo . Dessa forma, sabendo a primeira derivada, \\frac{dx}{dt} \\frac{dx}{dt} , e a condi\u00e7\u00e3o inicial, x_0 = x(0) x_0 = x(0) , conseguimos calcular os bens futuros. Assim, para encontramos x(t) x(t) que satisfa\u00e7a a nossa EDO, basta integramos x(t) = \\int_0^t \\dfrac{dx}{dt} dt x(t) = \\int_0^t \\dfrac{dx}{dt} dt","title":"O Problema"},{"location":"simulacoes/finances/#1a-modelagem","text":"Vamos come\u00e7ar com um caso simples. Nossas finan\u00e7as s\u00e3o baseadas nos seguintes fatores: Nossa renda mensal, r(t) r(t) . Todas as nossas despesas (contas, alimenta\u00e7\u00e3o, moradia, etc), d(t) d(t) . As taxas que voc\u00ea paga sobre o seu sal\u00e1rio, T(a) T(a) . Dessa forma podemos dizer que o seu ganho, i.e., a taxa com que voc\u00ea ganha ou perde dinheiro pode ser escrita como \\delta = r(t) - d(t) - T(a) \\delta = r(t) - d(t) - T(a) Neste caso, \\delta \\delta \u00e9 o seu ganho. Assim, a EDO pode ser escrita como \\dfrac{dx}{dt} = \\delta \\dfrac{dx}{dt} = \\delta Dados r(t) r(t) , d(t) d(t) e T(a) T(a) constantes, podemos resolver integrando facilmente \\int_{x_0}^{x(t)} dx = \\int_0^t \\delta~dt \\Rightarrow x(t) = \\delta t + x_0 \\int_{x_0}^{x(t)} dx = \\int_0^t \\delta~dt \\Rightarrow x(t) = \\delta t + x_0 Como mantemos tudo constante, nossa equa\u00e7\u00e3o final ser\u00e1 uma reta. Transformando a matem\u00e1tica em c\u00f3digo teremos o seguinte: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Carteira : def __init__ ( self , salario = 1600 , despesas = 500 , taxas =. 1 ): self . salario = salario self . despesas = despesas self . taxas = taxas def ganho ( self , t ): return 12 * self . salario def gastos ( self , t ): return 12 * self . despesas def pagamentos ( self , t ): return self . taxas * self . ganho ( t ) def modelo ( self , t ): return self . ganho ( t ) - self . gastos ( t ) - self . pagamentos ( t ) def integrar ( self , t_init , t_end , y0 , h = 0.001 ): N = int (( t_end - t_init ) / h ) x = np . linspace ( t_init , t_end , N ) y = np . zeros ( N ) y [ 0 ] = y0 for i in range ( N - 1 ): y [ i + 1 ] = y [ i ] + h * self . modelo ( x [ i ]) return x , y Com um sal\u00e1rio de 1600 reais, despesas de 500 reais e os descontos salariais de 10%, teremos a reta abaixo. Vale dizer que a granularidade temporal \u00e9 de um ano. Para integrar a nossa EDO, ao inv\u00e9s de usar um pacote pronto, escrevemos a fun\u00e7\u00e3o integrar () . Essa fun\u00e7\u00e3o \u00e9 a implementa\u00e7\u00e3o do m\u00e9todo de Euler para resolver EDOs - veja mais aqui . Parando para ver o nosso modelo, n\u00e3o faz sentido pensarmos que desde que nascemos ganhemos um sal\u00e1rio. Al\u00e9m disso, todos queremos nos aposentar um dia. No nosso modelo, trabalhamos at\u00e9 morrer aos 100 anos. Bem, fica dif\u00edcil viver at\u00e9 os 100 trabalhando desde o nascimento... Vamos introduzir isso ao modelo!","title":"1\u00aa Modelagem"},{"location":"simulacoes/finances/#1a-modelagem-descontinuidades","text":"Como a integral \u00e9 um operador linear - uma maneira bonitinha de dizer que a integral da soma \u00e9 a soma das integrais. Dessa forma, \u00e9 v\u00e1lido fazermos a seguinte opera\u00e7\u00e3o: x(t) = \\int_{nascimento}^{t_1} \\dfrac{dx}{dt}~dt + \\int_{t_1}^{t_2} \\dfrac{dx}{dt}~dt + \\int_{t_2}^{morte} \\dfrac{dx}{dt}~dt x(t) = \\int_{nascimento}^{t_1} \\dfrac{dx}{dt}~dt + \\int_{t_1}^{t_2} \\dfrac{dx}{dt}~dt + \\int_{t_2}^{morte} \\dfrac{dx}{dt}~dt Dessa forma teremos 3 momentos distintos nas nossas vidas Inf\u00e2ncia: quando somos dependentes dos nossos pais e n\u00e3o temos um sal\u00e1rio e nem despesas. Vida Ativa: quando ganhamos, gastamos e pagamos taxas. Aposentadoria: quando n\u00e3o temos mais um sal\u00e1rio, mas ganhamos uma aposentadoria que \u00e9 menor que o nosso sal\u00e1rio. Al\u00e9m disso ainda temos despesas e taxas. Nosso c\u00f3digo muda um pouco. Vamos acrescentar essas descontinuidades ao ganho e aos gastos. Para integrar esse modelos agora, definimos uma fun\u00e7\u00e3o simula\u00e7\u00e3o. Nela executamos integramos passo a passo cada um dos est\u00e1gios. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 class Carteira : def __init__ ( self , salario = 1600 , despesas = 500 , taxas =. 1 , aposentadoria = 1000 , atividade = 18 , descanso = 70 ): self . salario = salario self . despesas = despesas self . taxas = taxas self . aposentadoria = aposentadoria self . atividade = atividade self . descanso = descanso def ganho ( self , t ): if t < self . atividade : return 0 elif self . atividade <= t < self . descanso : return 12 * self . salario else : return 12 * self . aposentadoria def gastos ( self , t ): if t < self . atividade : return 0 else : return 12 * self . despesas def pagamentos ( self , t ): return self . taxas * self . ganho ( t ) def modelo ( self , t ): return self . ganho ( t ) - self . gastos ( t ) - self . pagamentos ( t ) def integrar ( self , t_init , t_end , y0 , h = 0.001 ): N = int (( t_end - t_init ) / h ) x = np . linspace ( t_init , t_end , N ) y = np . zeros ( N ) y [ 0 ] = y0 for i in range ( N - 1 ): y [ i + 1 ] = y [ i ] + h * self . modelo ( x [ i ]) return x , y def simulacao ( carteira ): x0 , y0 = carteira . integrar ( 0 , carteira . atividade , 0 ) x1 , y1 = carteira . integrar ( carteira . atividade , carteira . descanso , y0 [ - 1 ]) x2 , y2 = carteira . integrar ( carteira . descanso , 100 , y1 [ - 1 ]) return np . concatenate (( x0 , x1 , x2 )), np . concatenate (( y0 , y1 , y2 )) Mesmo com a fun\u00e7\u00e3o \\frac{dx}{dt} \\frac{dx}{dt} tendo uma s\u00e9rie de descontinuidades, a fun\u00e7\u00e3o x(t) x(t)","title":"1\u00aa Modelagem + Descontinuidades"},{"location":"simulacoes/finances/#2a-modelagem","text":"Bem, a menos que sejamos alunos de inicia\u00e7\u00e3o cient\u00edfica, n\u00f3s esperamos que o nosso sal\u00e1rio aumente em fun\u00e7\u00e3o do tempo. Al\u00e9m disso, \u00e9 f\u00e1cil pensarmos que nossos gastos tamb\u00e9m aumentaram em fun\u00e7\u00e3o do tempo. \\begin{cases} r(t) = \\alpha~t + r_0\\\\ d(t) = \\beta~t + d_0\\\\ \\end{cases} \\begin{cases} r(t) = \\alpha~t + r_0\\\\ d(t) = \\beta~t + d_0\\\\ \\end{cases} Neste caso, \\alpha \\alpha \u00e9 a taxa de aumento salarial, ou o reajuste salarial, e \\beta \\beta o aumento das despesas, ou o reajuste de despesas. Agora nossa fun\u00e7\u00e3o \\delta \\delta ser\u00e1 dependente do tempo. Esta depend\u00eancia temporal na derivada primeira trar\u00e1 um perfil quadr\u00e1tico na fun\u00e7\u00e3o x(t) x(t) . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 class Carteira : def __init__ ( self , salario = 1600 , despesas = 500 , taxas =. 1 , aposentadoria = 1000 , atividade = 18 , descanso = 70 , alpha = 120 , beta = 80 ): self . salario = salario self . despesas = despesas self . taxas = taxas self . aposentadoria = aposentadoria self . atividade = atividade self . descanso = descanso self . reajuste_salarial = alpha self . reajuste_despesas = beta def ganho ( self , t ): if t < self . atividade : return 0 elif self . atividade <= t < self . descanso : return 12 * ( self . salario + self . reajuste_salarial \\ * ( t - self . atividade )) else : return 12 * self . aposentadoria def gastos ( self , t ): if t < self . atividade : return 0 else : return 12 * ( self . despesas + self . reajuste_despesas \\ * ( t - self . atividade )) def pagamentos ( self , t ): return self . taxas * self . ganho ( t ) def modelo ( self , t ): return self . ganho ( t ) - self . gastos ( t ) - self . pagamentos ( t ) def integrar ( self , t_init , t_end , y0 , h = 0.001 ): N = int (( t_end - t_init ) / h ) x = np . linspace ( t_init , t_end , N ) y = np . zeros ( N ) y [ 0 ] = y0 for i in range ( N - 1 ): y [ i + 1 ] = y [ i ] + h * self . modelo ( x [ i ]) return x , y def simulacao ( carteira ): x0 , y0 = carteira . integrar ( 0 , carteira . atividade , 0 ) x1 , y1 = carteira . integrar ( carteira . atividade , carteira . descanso , y0 [ - 1 ]) x2 , y2 = carteira . integrar ( carteira . descanso , 100 , y1 [ - 1 ]) return np . concatenate (( x0 , x1 , x2 )), np . concatenate (( y0 , y1 , y2 )) Como podemos ver, a nossa fun\u00e7\u00e3o exibe o perfil quadr\u00e1tico que previmos anteriormente. Al\u00e9m disso, vemos grandes diferen\u00e7as nos resultados das integra\u00e7\u00f5es. E bem, como estamos devendo, talvez seja hora de come\u00e7armos a investir para sairmos desse vermelho.","title":"2\u00aa Modelagem"},{"location":"simulacoes/finances/#3a-modelagem","text":"Agora chegou aquele momento de lembrarmos das aulas de engenharia econ\u00f4mica e da m\u00e1gica dos juros compostos. A f\u00f3rmula para isso \u00e9 f\u00e1cil M = C\\cdot(1+i)^n M = C\\cdot(1+i)^n onde, M M \u00e9 o montante, C C o capital inicial, i i a taxa de juros compostos e n n o per\u00edodo de aplica\u00e7\u00e3o. A \"m\u00e1gica\" dos juros compostos na verdade \u00e9 a aplica\u00e7\u00e3o de juros sobre juros, ou seja, \u00e9 como se peg\u00e1ssemos tudo o que j\u00e1 ganhamos e invest\u00edssemos novamente sobre o mesmo regime de juros. Mas vamos lembrar que estamos trabalhando com EDOs, assim vamos tomar a derivada dessa equa\u00e7\u00e3o: \\begin{cases} x(t) = x_0(1+i)^t\\\\ \\dfrac{dx}{dt} = x_0(1+i)^t\\ln{(R+1)} = x(t)\\ln{(R+1)} \\end{cases} \\begin{cases} x(t) = x_0(1+i)^t\\\\ \\dfrac{dx}{dt} = x_0(1+i)^t\\ln{(R+1)} = x(t)\\ln{(R+1)} \\end{cases} Como podemos ver, a derivada da fun\u00e7\u00e3o juros composto \u00e9 proporcional a ela mesma. Agora \u00e9 onde tudo fica ainda mais interessante. Com essa nova equa\u00e7\u00e3o diferencial podemos introduzir um fator investimento na nossa carteira. Todavia, ao inv\u00e9s de fixarmos um capital inicial, vamos disponibilizar um fator \\beta \\beta do nosso dinheiro para ser investido, onde \\beta\\in[0, 1] \\beta\\in[0, 1] . Dessa forma teremos a seguintes equa\u00e7\u00f5es: \\begin{cases} \\dot{x_1} = (1-\\beta)~\\delta\\\\ \\dot{x_2} = \\beta~\\delta + x_2\\ln{(1+R)} \\end{cases} \\begin{cases} \\dot{x_1} = (1-\\beta)~\\delta\\\\ \\dot{x_2} = \\beta~\\delta + x_2\\ln{(1+R)} \\end{cases}","title":"3\u00aa Modelagem"}]}